README File for Dijkstra's Programming Project 

McKenzie Allaben and Bijay Ranabhat
Algorithmic Graph Theory 


How to input a graph file: 

In order for the program to read and run the algorithm on a certain graph, the user must go into the source code and change the text file that is being read in the static main method to be the correct file name. The file must be a txt file. 

Correct format for the txt file representing the graph/network: 

Sample Format: 

//labeling the vertices of the graph beind read by the program. You must have characters starting with the source as 'a', representing the vertices of the graph
v1 a  
v2 b
v3 c 
v4 d
v5 e 
v6 f 
# 
v1 v2 2.0 //first v is vertex edge is extending from, second v is vertex edge is extending to 
v1 v3 8.0 
v2 v3 6.0 
v2 v4 3.0 
v3 v2 5.0 
v3 v5 0.0 
v4 v3 1.0 
v4 v5 7.0 
v4 v6 6.0 
v5 v4 4.0 
v5 v6 2.0


How to interpret the output txt file generated by the program: 

*********************************** EXAMPLE OUTPUT FILE *****************************************
Computing paths from a   

/* 
The first initial iteration 0 establishes that for vertex a the distance is 0 and predecessor is a. All other vertices have a distance of inifinity and a predecessor of a. 
*/ 
__________________________________________________________________________________________________
Itr: 0
Distance to a:0.0
Pred: a
All vertices except for vertex 'a' have a distance of INFINITY and the predecessor as vertex 'a'.

__________________________________________________________________________________________________

/* Read code first. In iteration 1, the root node is a, the nodes b and c are changed. Any nodes not listed as a target in this interation are infinity and predecessor a. 

a = 0,a  b = 2,a  c = 8,a  d = INF,a  e = INF,a  f = INF,a

*/ 

Itr: 1

Any vertex in the graph, that is not listed as a target in this iteration can be assumed to have the distance and predcessor values previously assigned in the last iteration. 

#Root Node: a 
Target:b
Distance to b: 2.0
Pred: a 
Path: [a , b]
In Queue: [b]


#Root Node: a 
Target:c 
Distance to c : 8.0
Pred: a 
Path: [a , c ]
In Queue: [b, c ]

__________________________________________________________________________________________________

/*In iteration 2, the root node is b, the node d is changed. Any nodes not listed as a target in this interation are infinity and predecessor a or the values of distance/predecessor that were previously changed in the iteration before this one. 

a = 0,a  b = 2,a  c = 8,a  d = 5,b  e = INF,a  f = INF,a

*/

Itr: 2

Any vertex in the graph, that is not listed as a target in this iteration can be assumed to have the distance and predcessor values previously assigned in the last iteration. 

#Root Node: b
Target:d
Distance to d: 5.0
Pred: b
Path: [a , b, d]
In Queue: [d]

__________________________________________________________________________________________________

/*In iteration 3, the root node is d, the nodes c, e, and f are changed. Any nodes not listed as a target in this interation are infinity and predecessor a or the values of distance/predecessor that were previously changed in the iterations before this one. 

a = 0,a  b = 2,a  c = 6,d  d = 5,b  e = 12,d  f = 11,d

*/

Itr: 3

Any vertex in the graph, that is not listed as a target in this iteration can be assumed to have the distance and predcessor values previously assigned in the last iteration. 

#Root Node: d
Target:c 
Distance to c : 6.0
Pred: d
Path: [a , b, d, c ]
In Queue: [c ]


#Root Node: d
Target:e 
Distance to e : 12.0
Pred: d
Path: [a , b, d, e ]
In Queue: [c , e ]


#Root Node: d
Target:f 
Distance to f : 11.0
Pred: d
Path: [a , b, d, f ]
In Queue: [c , e , f ]

__________________________________________________________________________________________________

/*In iteration 4, the root node is c, the node e is changed. Any nodes not listed as a target in this interation are infinity and predecessor a or the values of distance/predecessor that were previously changed in the iterations before this one. 

a = 0,a  b = 2,a  c = 6,d  d = 5,b  e = 6,c  f = 11,d

*/

Itr: 4

Any vertex in the graph, that is not listed as a target in this iteration can be assumed to have the distance and predcessor values previously assigned in the last iteration. 

#Root Node: c 
Target:e 
Distance to e : 6.0
Pred: c 
Path: [a , b, d, c , e ]
In Queue: [e ]

__________________________________________________________________________________________________

/*In iteration 5, the root node is e, the node f is changed. Any nodes not listed as a target in this interation are infinity and predecessor a or the values of distance/predecessor that were previously changed in the iterations before this one. This is the final iteration for example as vertex f is the terminus of the graph. 

a = 0,a  b = 2,a  c = 6,d  d = 5,b  e = 6,c  f = 8,e

*/

Itr: 5

Any vertex in the graph, that is not listed as a target in this iteration can be assumed to have the distance and predcessor values previously assigned in the last iteration. 

#Root Node: e 
Target:f 
Distance to f : 8.0
Pred: e 
Path: [a , b, d, c , e , f ]
In Queue: [f ]

__________________________________________________________________________________________________

/*

Listed is the shortest paths to each of the vertices from the source a. The path listed to terminus f, is the shortes path from source to terminus. Therefore, the algorithm is complete. The amount of time the computer took to complete the algorithm is listed below for reference.  

*/

SHORTEST PATH DETERMINED (LAST ITERATION):
Distance to a : 0.0
Path: [a ]

Distance to b: 2.0
Path: [a , b]

Distance to c : 6.0
Path: [a , b, d, c ]

Distance to d: 5.0
Path: [a , b, d]

Distance to e : 6.0
Path: [a , b, d, c , e ]

Distance to f : 8.0
Path: [a , b, d, c , e , f ]

It took 0.02 seconds to solve the problem.
